//Writing about the global score function 

everytime a meteor is near the rocket under information radius
	increase the "learning" value by 1
	since in this implementation we are calculating the value of collision in each frame
	We will find the total number of collison 
	use this value to evaluate the score function
	on the end of the loop we will reset the "learning value to zero"

--> This update shall be merged with the master branch.
--> fix for the reference shall be generated before launching the guides in code
--> Or the error in code shall be hidden when running the game without the reference flagup
--> High score bar and current score monitor shall be made and this shall be displayed on the screen during the game runtime


//Neuron control for the system 

1. Randomly generate a neural network that can be evaluated to find the resulting motion
of the rocket
2. game has a way to read the neuron and register the motion of the rocket using the vaue generated from the neural network framework


//Genetic algorithm 

--> A class is needed to look up the function of game and monitor the progress generated by the AI
--> Genetically develop the neural network the using various instances of the rocket
--> The game shall be modified to run the multiple instance of the game
--> The Aim of this implementation will to generate an AI capable of playing game.
--> We will monitor the health of the AI 
--> --> that will tell us the orientation of the AI i.e. what does it prefer
--> --> For example we will try to detect that is the AI is left handed or right handed
--> --> Is it high speeding to escape the problem or low speeding in order to escape the problem

//Q learning 

--> This will be same as the genetic implementation 
--> In this we have to reinfore the learning using incentive of surival in form of reward
--> Reward will be HighScore/Time ratio to differentiate between who aggrisively gain the point to develop a fast paced rocket

// The result from both the implementation shall be compared to identify how the models have developed in order to solve the problem in their surrounding 

--> Both the implementation will maintain a ledger that stores the data about the performance of both implementation

// Final demonstration is the implementation of monte carlo simulation to predict the possible model to work with
